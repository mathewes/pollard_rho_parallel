#!/usr/bin/perl
use PARI::822;

PARI::822::read(\%funcs, "pari.desc");

open (FILE, "../../doc/usersFUNCS.tex") || die;
while (<FILE>)
{
  if (/^% *SECTION *: *(.*) */)
  {
    my ($sec) = $1;
    for ( sort grep { $funcs{$_}->{Section} eq $sec } keys %funcs ) {
      my ($fun) = $funcs{$_};
      my ($doc) = $fun->{Doc};
      next if (!defined($doc));

      my ($args)  = $fun->{Help};
      my ($v);
      $args =~ s/ *:.*//s;
      if (!$args || $args =~ /^\w+=\w+\(\)/) { $args = $v = ''; }
      else
      {
        $args =~ s/^[^(]*\((.*)\)/$1/; # args proper
        $v = $args;
        $v =~ s/([{}&])/\\$1/g;
        $v =~ s/\^(\d+)/^{$1}/g;
        $v =~ s/\[\]/[\\,]/g;
        $v =~ s/(\w\w+)/\\var{$1}/g;
        $v =~ s/\^([a-z])/\\hbox{\\kbd{\\pow}}$1/g;
        $v =~ s/\\var{flag}/\\fl/g;

        $v = "\$($v)\$";
      }
      if ($doc !~ /\\syn\w*{/ && $sec !~ /programming\/control/) {
        $doc .= library_syntax($fun, $args);
      }
      s/_def_//;
      my ($secname) = $_;
      my ($l) = $_;
      $l = "def,$l" if ($fun->{Section} =~ 'default');
      if ($secname =~ s/_/\\_/g) {
        print "\n\\subsec{$secname}$v: \\kbdsidx{$l}\\label{se:$l}$doc\n";
      } else {
        print "\n\\subsecidx{$secname}$v: \\label{se:$l}$doc\n";
      }
    }
  }
  print;
}

sub library_syntax { my ($fun, $args) = @_;
  return '' if ($fun->{Class} =~ /^(highlevel|gp|default|gp_default)$/);
  my ($Cname) = $fun->{'C-Name'};
  my ($Variant) = $fun->{Variant};
  my (@proto) = split(//, $fun->{Prototype});
  $args =~ s/[{}&]//g;
  $args =~ s/=[^,\)]*//g; # delete default values
  my (@ARGS) = split(/[,^] */, $args); # ^ for O(p^e)
  my ($type) = "GEN";
  $args = ''; @vars=();
  for ($i = 0; $i <= $#proto; )
  {
    my ($c) = $proto[$i++];
    if ($c eq 'l') { $type = "long"; next; }
    if ($c eq 'v') { $type = "void"; next; }

    if ($c =~ /^[GWIE]$/) {$args .= ", GEN " . shift(@ARGS); next;}
    if ($c eq 'L') {$args .= ", long " . shift(@ARGS); next;}
    if ($c eq 'n') {my ($v) = shift(@ARGS); push @vars,"\\kbd{$v}";
                    $args .= ", long " . $v; next;}
    if ($c =~ /^[rs]$/) {$args .= ", const char *" . shift(@ARGS); next;}

    if ($c eq 'p') {$args .= ", long prec"; next;}
    if ($c eq 'P') {$args .= ", long precdl"; next;}
    if ($c eq 'C') {$args .= ", GEN ctx"; next;}
    if ($c eq '') { next; }
    if ($c eq 'D') {
      $c = $proto[$i++];
      if ($c eq 'G') {$args .= ", GEN " . shift(@ARGS) ." = NULL"; next;}
      if ($c =~ /^[rs]$/) {$args .= ", const char *" . shift(@ARGS) ." = NULL"; next;}
      if ($c eq '&') {$args .= ", GEN *". shift(@ARGS) ." = NULL"; next;}
      if ($c eq 'P') {$args .= ", long precdl"; next;}
      if ($c eq 'n') {
        my ($v) = shift(@ARGS);
        $args .= ", long $v = -1";
        push @vars,"\\kbd{$v}";
        next;
      }
      if ($c eq 'V') {
        next;
      }
      if ($c =~ /^[EI]$/) {
        $args .= ", GEN ". shift(@ARGS) ." = NULL"; next;
      }
      while (($c = $proto[$i++]) ne ',') {}
    }
  }
  $args =~ s/^, //;

  my ($l)=scalar @vars;
  if ($l==0) { $post=""; }
  elsif ($l==1)
  {
    $post = ", where $vars[0] is a variable number";
  }
  else
  {
    my ($vl)=join(", ",@vars);
    $post = ", where $vl are variable numbers";
  }
  my ($txt) = "\n\nThe library syntax is \\fun{$type}{$Cname}{$args}$post.";
  $txt .= "\n$Variant" if ($Variant);
  return $txt;
}
